# 并行计算实验一

> 2021310752 刘丰源

## 项目构成

- main.cpp：集合通信实现
- config/\*.txt：配置文件，包括操作符、数据大小、root 结点。
- reader.h：解析 config 文件
- run.sh：快捷运行脚本

## 运行方式

```sh
# config 目录下有所有作业基本要求的指令对应的配置文件
# eg: bash run.sh config/bcast.txt 8
bash run.sh {CFG_PATH} {NPROC}
```

## 代码说明

### reader.h

用于解析 config 文件。

config example：

```
operation: all_reduce_sum
data_size: 10000000
root_id: 2
```

以冒号（:）为分隔符，前面的为变量名，后面的为变量值，可以自动扣除多余的空格。

### main.cpp

在代码中加入了足量且详细的注释。

除了基础的带宽输出，还增加了数据正确性检查，会将发送的数组初始化成特定的值，并检查接收到的值是否符合预期，具体见 main.cpp:117 。

## 运行结果

> 测试节点个数为 8
> 每次运行结果都有波动，记录内容为：去掉头尾的 10%，多次平均保留两位有效数字后取整

### bcast

| int array lenth | band width(MB/S) |
| --------------- | ---------------- |
| 10              | 4                |
| 100             | 48               |
| 1000            | 280              |
| 10000           | 1700             |
| 100000          | 2000             |
| 1000000         | 3200             |
| 10000000        | 4300             |

根结点把自己的数据发给所有人。

### gather

| int array lenth | band width(MB/S) |
| --------------- | ---------------- |
| 10              | 1                |
| 100             | 20               |
| 1000            | 100              |
| 10000           | 400              |
| 100000          | 1000             |
| 1000000         | 1800             |
| 10000000        | 2000             |

根节点接受所有人的信息。

gather 比 bacast 慢，是因为接收信息的结点压力太大有堵塞。

### reduce_sum

| int array lenth | band width(MB/S) |
| --------------- | ---------------- |
| 10              | 4                |
| 100             | 49               |
| 1000            | 120              |
| 10000           | 1000             |
| 100000          | 1300             |
| 1000000         | 1900             |
| 10000000        | 2400             |

只有 ROOT 进程会收到数据。

### all_reduce_sum

| int array lenth | band width(MB/S) |
| --------------- | ---------------- |
| 10              | 5                |
| 100             | 55               |
| 1000            | 350              |
| 10000           | 1400             |
| 100000          | 2100             |
| 1000000         | 3100             |
| 10000000        | 3700             |

所有进程都会收到算好的数据。

### scan_sum

| int array lenth | band width(MB/S) |
| --------------- | ---------------- |
| 10              | 1                |
| 100             | 11               |
| 1000            | 100              |
| 10000           | 490              |
| 100000          | 600              |
| 1000000         | 740              |
| 10000000        | 850              |

存在串行，所以较慢。

### all_to_all

| int array lenth | band width(MB/S) |
| --------------- | ---------------- |
| 10              | 5                |
| 100             | 14               |
| 1000            | 280              |
| 10000           | 1900             |
| 100000          | 3000             |
| 1000000         | 5000             |
| 10000000        | 5500             |

如果把数据排列成二维的结构，这个操作有点像矩阵转置。
